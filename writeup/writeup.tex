\documentclass[a4paper]{scrartcl}

\usepackage[usenames,dvipsnames]{xcolor}

\title{Camera Based 2D Feature Tracking ReadMe}
\author{Philipp Rapp}
\date{\today}

\begin{document}

\maketitle

\section*{Mid-Term Report}
\subsection*{MP.0 Mid-Term Report}
\textcolor{gray}{\textit{Provide a Writeup / README that includes all the rubric points and how you addressed each one. You can submit your writeup as markdown or pdf.}}

The document at hand represents the readme file.

\section*{Data Buffer}
\subsection*{MP.1 Data Buffer Optimization}
\textcolor{gray}{\textit{Implement a vector for dataBuffer objects whose size does not exceed a limit (e.g. 2 elements). This can be achieved by pushing in new elements on one end and removing elements on the other end.}}

In order to solve this task, I decided to implement a ring buffer.
A ring buffer can be implemented by creating a plain array with a fixed capacity (in this case 2 elements)
and keeping track of
\begin{itemize}
	\item the current first entry (the head) and
	\item the occupied slots (the size).
\end{itemize}
In order to have reusable code, I used a template for both the data type as well as
for the capacity.
In order to have the same ease of use as for the STL vector, I also implemented a (non-complete)
iterator class for the ring buffer.

\section*{Keypoints}
\subsection*{MP.2 Keypoint Detection}
\textcolor{gray}{\textit{Implement detectors HARRIS, FAST, BRISK, ORB, AKAZE, and SIFT and make them selectable by setting a string accordingly.}}

I implemented the selection via string by creating an if-else branch (with lots of else cases).
The last else makes sure that a valid keypoint detector has been selected.

In each branch, the respective keypoint detection function is used.
For the actual keypoint detection, I used the functions which are already provided in the OpenCV
and stayed closely to the preceding exercises.
When parameters had to be chose for the detectors, I used those from the preceding exercises.

\subsection*{MP.3 Keypoint Removal}
\textcolor{gray}{\textit{Remove all keypoints outside of a pre-defined rectangle and only use the keypoints within the rectangle for further processing.}}

In order to solve this task, I created a second vector to hold keypoints.
This vector will contain all keypoints within the rectangle.
Note that I created this vector outside the if branch, in order to ensure that it does not
loose its scope.
The STL function \texttt{copy\_if} lends itself to copy only those keypoints to the new vector
which are inside the rectangle.
The function takes the original keypoint vector, the (in the beginning empty) keypoint vector
for the points within the rectangle, as well as a lambda function that checks whether or
not the keypoint is within the rectangle, which is computed by means of the OpenCV method \texttt{contains}.
Finally, the keypoint vectors are swapped so that the original variable holds the keypoints
within the rectangle.

\section*{Descriptors}
\subsection*{MP.4 Keypoint Descriptors}
\textcolor{gray}{\textit{Implement descriptors BRIEF, ORB, FREAK, AKAZE and SIFT and make them selectable by setting a string accordingly.}}

I solved this task by implementing an if-else branch (with lots of else cases).
While I was at it, I also added another output argument of type \texttt{DescriptorType}
which specifies whether the descriptor is a binary descriptor or wheter it is a HOG
(histogram of oriented gradients) descriptor.
This comes in handy later, as it avoids the manual and therefore error-prone specification
of the descriptor type when matching keypoints.

The descriptors itself are all taken directly from OpenCV. I used the default parameters
in the respective create method.

\subsection*{MP.5 Descriptor Matching}
\textcolor{gray}{\textit{Implement FLANN matching as well as k-nearest neighbor selection. Both methods must be selectable using the respective strings in the main function.}}


\subsection*{MP.6 Descriptor Distance Ratio}

\section*{Performance}
\subsection*{MP.7 Performance Evaluation 1}
\subsection*{MP.8 Performance Evaluation 2}
\subsection*{MP.9 Performance Evaluation 3}


\end{document}